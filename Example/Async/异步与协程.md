# 异步与协程

### C#
C#异步通过多线程实现，异步任务可以立即执行
```csharp
namespace CsharpUse;

public class AsyncPractise
{
    static async Task g()
    {
        Console.WriteLine("g 1");
        await Task.Delay(1000);
        Console.WriteLine("g 2");
    }
    static async Task f()
    {
        var a = g();
        Console.WriteLine("f 1");
        await a;
        Console.WriteLine("f 2");
    }

    public static void Main()
    {
        f().GetAwaiter().GetResult();
    }
    
    // g 1
    // f 1
    // g 2
    // f 2
}
```

### python
python异步通过协程实现, 触发异步任务后，需要主干代码让出线程所有权，异步任务才会执行
```python
import asyncio


async def g():
    print("g 1")
    await asyncio.sleep(1)
    print("g 2")


async def f():
    a = asyncio.create_task(g())
    await asyncio.sleep(0) # return control to loop so task can start
    print("f 1")
    await a
    print("f 2")


async def main():
    await f()


if __name__ == '__main__':
    asyncio.run(main())

# g 1
# f 1
# g 2
# f 2
```

### Rust
rust异步任务库tokio使用绿色线程类似协程实现异步任务，异步任务也需要主干代码让出线程所有权，异步任务才会执行
```rust
use std::time::Duration;

async fn g() {
    println!("g 1");
    tokio::time::sleep(Duration::from_secs(1)).await;
    println!("g 2");
}

async fn f() {
    let a = tokio::spawn(g());
    tokio::task::yield_now().await;
    println!("f 1");
    a.await.unwrap();
    println!("f 2");
}

#[tokio::main]
async fn main() {
    f().await
}

// f 1
// g 1
// g 2
// f 2
```

### TypeScript
Promise一经创建就会立马执行。但是Promise.then中的方法，则会等到一个调用周期过后再次调用，await Promise调用的代码就会停止直到Promise被解决或被拒绝
```typescript
const sleep = (delay: number) => new Promise(r => setTimeout(r, delay))

async function g(): Promise<any> {
    console.log("g 1")
    await sleep(1000)
    console.log("g 2")
}

async function f(): Promise<any> {
    let a = g()
    console.log("f 1")
    await a
    console.log("f 2")
}

async function out(): Promise<any> {
    let b = f()
    console.log("start")
    await b
    console.log("finish")
}

out().then(() => {
    console.log("Success")
}).catch(err => {
    console.log(err)
})

// g 1
// f 1
// start
// g 2
// f 2
// finish
// Success
```
